/*
 * Day 0 - AI Apocalypse by inventr.io
 * Learn more at https://inventr.io/PLACEHOLDER
 *
 * That works, but it's pretty boring and doesn't really make use of the different
 * colors in our RGB LED and we're only using ONE of our remote's buttons.  Let's
 * modify that last sketch and add the capability to turn each color on and off.  We
 * can use 1 to toggle red LED on/off, 4 a for the green LED and lastly 7 to control
 * the blue LED.
 *
 * This will give us 7 different colors:
 * Red, Green, Blue, magenta (red/blue), Yellow (red/green), Cyan (blue/green) and
 * White (red/green/blue)
 *
 * Alex Eschenauer
 * David Schmidt
 */

#include "Arduino.h"
#include <IRremote.h>

/* Choosing what pin to use.
 * This project only needs digital pins.  So, on the Hero XL we *could* use any digital or analog pin
 * (D0-D53, A0-A15).  However, some pins support specialized functions and in later lessons we will be
 * using multiple parts, some of which will use some of those special functions.  So, let's start out
 * on the right foot by trying to use the most basic pin we can for each of our parts.
 *
 * Skip: A0-A15 (save for Analog),
 *       D0/D1 (used by USB and Serial)
 *       D14-D19 (used by Serial 1-3)
 *       D2/D3, D18-D21 (used for external interrupts)
 *       D13 (this pin controls the build in LED on the HERO XL board (LED_BUILTIN)),
 *       D2-D13, D44-D46 (used for Pulse Width Modulation (PWM))
 *       D50 (MISO), D51 (MOSI), D52 (SCK), D53 (SS).  (used for SPI communication)
 *       D20 (SDA), D21 (SCL).  (used for I2C communication using the Wire library)
 * Recommended for fewest conflicts:
 *    D22-D43, D47-D49, A8-A15
 */

const uint8_t IR_SIGNAL_PIN = 28;  // Signal Pin of IR receiver

// RGB LED control pins
const uint8_t RED_PIN = 22;
const uint8_t GREEN_PIN = 24;
const uint8_t BLUE_PIN = 26;

// Remap HIGH/LOW to ON/OFF for code readability
const uint8_t ON = HIGH;
const uint8_t OFF = LOW;

// This structure allows us to display a description for each recognized command
struct RemoteButton {
  unsigned int command;     // command generated by IR remote button
  const char* description;  // button description
};

// Define a constant equal to our decoded command for each of our remote's buttons
enum IR_COMMANDS {
  POWER_BUTTON = 69,
  BUTTON_0 = 22,
  BUTTON_1 = 12,
  BUTTON_2 = 24,
  BUTTON_3 = 94,
  BUTTON_4 = 8,
  BUTTON_5 = 28,
  BUTTON_6 = 90,
  BUTTON_7 = 66,
  BUTTON_8 = 82,
  BUTTON_9 = 74,
  VOLUME_UP_BUTTON = 70,
  VOLUME_DOWN_BUTTON = 21,
  FUNC_STOP = 71,
  REWIND = 68,
  PLAY_PAUSE = 64,
  FAST_FORWARD = 67,
  DOWN = 7,
  UP = 9,
  EQ = 25,
  ST_REPT = 13,
};

// Define what command each of our buttons generates.
const RemoteButton BUTTONS[] = {
  // Add more buttons and descriptions as we run the sketch and identify what commands go with each button
  { POWER_BUTTON, "Power button" },  // Add new buttons below this button
  { BUTTON_1, "Toggle Red"},
  { BUTTON_4, "Toggle Green"},
  { BUTTON_7, "Toggle Blue" },      // comma isn't required on last entry, but it doesn't hurt and makes insertions easier
};

const int BUTTON_COUNT = sizeof(BUTTONS) / sizeof(RemoteButton);

// Initialize our IR Remote library code.
IRrecv receiver(IR_SIGNAL_PIN);

void setup() {
  Serial.begin(9600);
  receiver.enableIRIn();  // Start the receiver

  // LED pins are all outputs
  pinMode(RED_PIN, OUTPUT);
  pinMode(GREEN_PIN, OUTPUT);
  pinMode(BLUE_PIN, OUTPUT);
}

// Track whether light is powered on or off, and last status of each color
uint8_t light_is_on = false;
uint8_t red_last_value = OFF;
uint8_t green_last_value = OFF;
uint8_t blue_last_value = OFF;

void loop() {
  // Checks received an IR signal
  if (receiver.decode()) {
    unsigned int IRCommand = receiver.decodedIRData.command;
    displayIRCommand(IRCommand);

    if (IRCommand == POWER_BUTTON) {
      if (light_is_on) {  // light is on, turn off
        Serial.println("turn off");
        setColor(OFF, OFF, OFF);
        light_is_on = false;
      } else {
        Serial.println("turn on");
        // If all LEDs were off, blink light twice to let user know it's enabled
        if (red_last_value == OFF && green_last_value == OFF && blue_last_value == OFF) {
          blinkLight();  // blink light twice to let user know it's ready for color commands
        } else {         // otherwise, turn light on with previous color
          setColor(red_last_value, green_last_value, blue_last_value);
        }
        light_is_on = true;
      }
    }

    if (light_is_on) {
      switch (IRCommand) {
        case BUTTON_1:  // Toggle red LED
          if (red_last_value == OFF) {
            digitalWrite(RED_PIN, ON);
            red_last_value = ON;
          } else {
            digitalWrite(RED_PIN, OFF);
            red_last_value = OFF;
          }
          break;
        case BUTTON_4:  // Toggle green LED
          if (green_last_value == OFF) {
            digitalWrite(GREEN_PIN, ON);
            green_last_value = ON;
          } else {
            digitalWrite(GREEN_PIN, OFF);
            green_last_value = OFF;
          }
          break;
        case BUTTON_7:  // Toggle BLUE LED
          if (blue_last_value == OFF) {
            digitalWrite(BLUE_PIN, ON);
            blue_last_value = ON;
          } else {
            digitalWrite(BLUE_PIN, OFF);
            blue_last_value = OFF;
          }
          break;
      }
    }
    delay(50);          // Delay to skip double presses
    receiver.resume();  // Receive the next value
  }
}

void displayIRCommand(unsigned int command) {
  for (int i = 0; i < BUTTON_COUNT; i++) {
    if (BUTTONS[i].command == command) {
      Serial.println(String(BUTTONS[i].description) + "(" + String(int(command)) + ")");
      return;
    }
  }
  Serial.println("Unrecognized command: " + String(command));
}

void setColor(int redValue, int greenValue, int blueValue) {
  digitalWrite(RED_PIN, redValue);
  digitalWrite(GREEN_PIN, greenValue);
  digitalWrite(BLUE_PIN, blueValue);
}

void blinkLight() {
  setColor(ON, ON, ON);  // Light on
  delay(500);
  setColor(OFF, OFF, OFF);  // Light off
  delay(500);
  setColor(ON, ON, ON);  // Light on
  delay(500);
  setColor(OFF, OFF, OFF);  // Light off
}
