/*
 * Day 0 - AI Apocalypse by inventr.io
 * Learn more at https://inventr.io/PLACEHOLDER
 *
 * Building a battery charging controller.
 *
 * We have batteries to store the power generated by our solar panels, but the charging
 * was handled by the building AI, which has been disabled.
 *
 * We'll use a HERO XL to control the charging and use of our battery array, using a
 * photoresistor to simulate our solar panels and variables in the code to track our
 * battery level.
 *
 * A photoresistor is a light-sensitive component that changes resistance based on the
 * amount of light it receives.  When light increases, the resistance decreases.
 *
 * Since we'll be powering our lights from the batteries we'll be adding on to our
 * previous switched light circuit and code.
 *
 * Alex Eschenauer
 * David Schmidt
 */

/*
 * Arduino language concepts introduced in this lesson.
 *
 *  - Analog input pins
 *  - Serial console
 *  - Serial plotter
 *  - Floating point numbers/variables
 */
#include "Arduino.h"

/* Choosing what pin to use.
 * This project only needs digital pins.  So, on the Hero XL we *could* use any digital or analog pin
 * (D0-D53, A0-A15).  However, some pins support specialized functions and in later lessons we will be
 * using multiple parts, some of which will use some of those special functions.  So, let's start out
 * on the right foot by trying to use the most basic pin we can for each of our parts.
 *
 * Skip: A0-A15 (save for Analog),
 *       D0/D1 (used by USB and Serial)
 *       D14-D19 (used by Serial 1-3)
 *       D2/D3, D18-D21 (used for external interrupts)
 *       D13 (this pin controls the build in LED on the HERO XL board (LED_BUILTIN)),
 *       D2-D13, D44-D46 (used for Pulse Width Modulation (PWM))
 *       D50 (MISO), D51 (MOSI), D52 (SCK), D53 (SS).  (used for SPI communication)
 *       D20 (SDA), D21 (SCL).  (used for I2C communication using the Wire library)
 * Recommended for fewest conflicts:
 *    D22-D43, D47-D49, A8-A15
 */
const uint8_t LIGHT = 22;          // LED on pin 22
const uint8_t LIGHT_BUTTON = 23;   // Button (light switch) on pin 23
const uint8_t CHARGING_RATE = A8;  // Photoresistor input simulating battery charge rate

/*
 * NOTE: While HIGH/LOW now make more sense when using a pull-down resistor, it still
 *       makes even MORE clear using PRESSED / NOT_PRESSED.  However, now we set
 *       PRESSED equal to HIGH.  We can also use ON / OFF for our lights.
 */
const uint8_t PRESSED = LOW;       // Button input pin reads LOW when pressed
const uint8_t NOT_PRESSED = HIGH;  // Button input pin reads HIGH when NOT pressed
const uint8_t ON = HIGH;           // Lights are ON when pin is HIGH
const uint8_t OFF = LOW;           // Lights are OFF when pin is LOW

/* Global Variables
 *
 * These variables need to maintain their state between runs of the loop so they
 * need to be defined with global variable scope.
 *
 * Since our battery will charge only a small amount every time through our loop
 * we need to track numbers smaller than 1.  Arduino language supports floating point
 * numbers (https://www.arduino.cc/reference/en/language/variables/data-types/float/)
 * and we'll use them in these sketches to track our battery charging.
 */
float battery_charge_percentage = 15.0;  // Battery level in percent.  Starts out low.

bool light_on = false;                     // we start with the light turned off
bool previous_button_state = NOT_PRESSED;  // start out with button NOT pressed

void setup() {
  // Intialize Serial class, used to communicate with the Arduino IDE Serial Monitor  
  Serial.begin(9600);   // Initialize Serial, set speed to 9600 bits/second (baud)
  while (!Serial) {
    ; // wait for serial port to connect.
  }
  pinMode(LIGHT, OUTPUT);               // LED representing our light (output)
  pinMode(LIGHT_BUTTON, INPUT_PULLUP);  // Button controlling light (input with pull-up resistor)
  pinMode(CHARGING_RATE, INPUT);        // Photoresistor analog input
}

// Here are some constants used to determine how much to add to our simulated battery every
// time through our loop().  Because they will be used in another constant expression they
// must be declared as "constexpr".  Many are also defined as floats to force the entire espression
// to use floating point math.

// Many battery type can be damaged over time if always charged to 100% or fully discharged.  Thus,
// in normal use we'll only charge up to the HIGH_BATTERY_LIMIT and turn off our batteries when
// LOW_BATTERY_LIMIT is reached.
constexpr float LOW_BATTERY_LIMIT = 10;   // Turn off power use when battery charge drops below this value
constexpr float HIGH_BATTERY_LIMIT = 90;  // Stop charging battery here to minimize battery degredation

// It is also hard on a battery when charging is started and stopped often.  Because of this, when we
// start drawing power from our HIGH_BATTERY_LIMIT we won't begin to charge until battery level drops
// below this level.
constexpr float START_CHARGING_AT = 85;  // Don't start charging unil battery level drops below this level

constexpr uint8_t SECONDS_TO_FULL = 30;    // For our simulation, fully charge battery in this many seconds
constexpr uint8_t LOOPS_PER_SECOND = 20;   // Run this many loops per second, quick enough for light switch
constexpr int AVERAGE_CHARGE_LEVEL = 530;  // Photoresistor reads approximately this value for room light.

// Now, using those constants we can calculate (at average room light) how much to charge our battery
// every time through our loop().  We could do this in one long calculation, but to show you how it was
// derived we'll show every incremental step.

// First, how many percentage points from our lowest charge to our highest charge?
constexpr float PERCENTAGE_FROM_EMPTY_TO_FULL = HIGH_BATTERY_LIMIT - LOW_BATTERY_LIMIT;

// We want to simulate a full charge in SECONDS_TO_FULL, so we charge this much per second
constexpr float PERCENTAGE_PER_SECOND = PERCENTAGE_FROM_EMPTY_TO_FULL / SECONDS_TO_FULL;

// To keep our light switch responsive, we run loop() many times per second using delay()
// so we'll add this much charge per loop() execution.
constexpr float PERCENTAGE_PER_LOOP = PERCENTAGE_PER_SECOND / LOOPS_PER_SECOND;

// This value is how much charge to add to our battery for every unit read from our
// photoresistor.  If our analog pin reads AVERAGE_CHARGE_LEVEL then we should reach
// full charge in SECONDS_TO_FULL seconds.
constexpr float AVERAGE_CHARGE_PER_LOOP = PERCENTAGE_PER_LOOP / AVERAGE_CHARGE_LEVEL;
// const float AVERAGE_CHARGE_PER_LOOP = (((HIGH_BATTERY_LIMIT - LOW_BATTERY_LIMIT) / SECONDS_TO_FULL) / LOOPS_PER_SECOND) / AVERAGE_CHARGE_LEVEL;

bool charging = true;

void loop() {
  /*
   * We can do more than one thing inside our loop() code.  Since the photoresistor is new
   * let's handle that first, but then we can still handle switching our light on/off.
   */
  int current_charging_rate = analogRead(CHARGING_RATE);    // Read "charging rate" from our photoresistor (0-1023)

  float new_charge = current_charging_rate * AVERAGE_CHARGE_PER_LOOP;
  if (light_on) {
    battery_charge_percentage = battery_charge_percentage - (2.0 / LOOPS_PER_SECOND);
  }
  if (charging && battery_charge_percentage < HIGH_BATTERY_LIMIT) {
    battery_charge_percentage = battery_charge_percentage + new_charge;
  }
  if (battery_charge_percentage > HIGH_BATTERY_LIMIT) {
    charging = false;
  }
  if (battery_charge_percentage < START_CHARGING_AT) {
    charging = true;
  }
  if (light_on && battery_charge_percentage < LOW_BATTERY_LIMIT) {
    digitalWrite(LIGHT, OFF);  // Light is on, turn it off
    light_on = false;          // ... and save it's new state
  }
  Serial.print(0);
  Serial.print(", ");
  Serial.print(100);
  Serial.print(", ");
  Serial.print(battery_charge_percentage);
  Serial.print(", ");
  Serial.println(map(current_charging_rate, 0, 1023, 0, 100));


  // Now let's check our light button and turn our light on/off appropriately.
  uint8_t button_state = digitalRead(LIGHT_BUTTON);  // read current button state and save it

  // first check to see if the button state has changed since last loop()
  if (button_state != previous_button_state) {
    if (button_state == PRESSED) {  // if our NEW state is PRESSED this is a new button press
      // then toggle our light, turning it of if it's on, and on if it's off.
      if (light_on) {
        digitalWrite(LIGHT, OFF);  // Light is on, turn it off
        light_on = false;          // ... and save it's new state
      } else {                     // Light must be off
        digitalWrite(LIGHT, ON);   // turn on light
        light_on = true;           // ... and save it's new state
      }
    }
    // Since button state changed, let's save its current state for next time through loop()
    previous_button_state = button_state;
  }

  // This delay isn't strictly necessary, but if we let the loop() run as quickly as it can
  // then we will use more power than necessary.  Let's check for a change in the button
  // state ever 20th of a second (1000 milliseconds / 20 = 50 milliseconds).  That is fast
  // enough that it will appear instantaneous to our users.
  delay(1000 / LOOPS_PER_SECOND);
}
